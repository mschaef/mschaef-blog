@Rhino supports a number of different optimization levels that allow different
trade offs to be made between performance, language features, and debuggability.
The optimization level is set in the Rhino with a call to the `setOptimizationLevel`
call on the interpreter context. RhinoWiki currently uses level -1:

     cx.setOptimizationLevel(-1);

Optimization level -1 selects interpreted execution. The interpeter is
slower than the compiler, but there are a number of side benefits to
using the interpreter. The interpreter produces more informative
stacktraces when an exception is thrown.  It also avoids a
proliferation of the generated temporary classes the compiler uses to
host its results. Every compiled expression results in a new class
being added to the JVM. This is probably acceptable in batch use, but
it's problematic when interacting witih the system via a REPL. (Until
I switched to the interpreter, I ran into a number of cases when I'd
redefine a function with the REPL and find that the new definition had
not taken place.) The other benefit to the interpreter is that
Rhino's @ResumableContinuations support only works in the interpreter.