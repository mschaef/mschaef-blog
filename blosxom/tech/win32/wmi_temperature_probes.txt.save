WMI and temperature probes...

I've spent a little more time spelunking around Win32's support for power 
and thermal management hardware. It seems like it should be possible to 
use Windows API calls to determine the presence of hardware temperature 
sensors and sample their current readings. As it turns out, with <a 
href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wmisdk/wmi/wmi_reference.asp">Windows 
Management Instrumentation (WMI)</a>, half of this is possible.

<br><br>

Quoting <a 
href="http://msdn.microsoft.com/library/en-us/wmisdk/wmi/about_wmi.asp?frame=true">MSDN</a>, 
<i>"Windows Management Instrumentation (WMI) is a component of the Windows operating system that 
provides management information and control in an enterprise environment. Administrators can use WMI 
to query and set information on desktop systems, applications, networks, and other enterprise 
components. Developers can use WMI to create event monitoring applications that alert users when 
important incidents occur."</i> Effectively, what that means is that there's a collection of COM 
objects that allow you to discover the hardware and software configuration of your local computer.  
With DCOM, it's possible to use this over the network to discover the same stuff on a remote 
machine. I'm guessing the intent is that the administrator of a server farm can use WMI services to 
aggregate statistics on her charges.

<br><br>

Reading the WMI documentation, one of the classes of information WMI makes available is <a 
href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wmisdk/wmi/win32_temperatureprobe.asp">Win32_TemperatureProbe</a>, 
, which "represents the properties of a temperature sensor (electronic thermometer)." Had I read 
further, I would have also read the following and saved myself some time: "current implementations 
of WMI do not populate the CurrentReading property", but that's beside the point: this road gets 
more interesting before hitting that particular dead end. Doing some <a 
href="http://www.google.com">research</a> on WMI and scripting led to a nice <a 
href="http://www.4guysfromrolla.com/webtech/082802-1.shtml">tutorial on WMI</a> at the <a 
href="http://www.4guysfromrolla.com/">4 Guys From Rolla</a> website. From that, it was pretty easy 
to piece together this little piece of code that dumps data from arbitrary WMI classes:

<pre class="syntax">

wscript.echo "Temperature, version 0.1"

sub ShowServices(vClass)
  'Declare our needed variables...
  Dim objLocator, objService, objWEBMCol, objWEBM, objProp, propitem, objItem, str

  Set objLocator = CreateObject("WbemScripting.SWbemLocator")
  Set objService = objLocator.ConnectServer() ' Connect to local PC

  Set objWEBM = objService.get(vclass) 
  Set objWEBMCol = objWEBM.Instances_ 
  Set objProp = objWebm.properties_ 


  For Each propItem in objProp
    str = propItem.Name

    For Each objItem in objWEBMCol 
       str = str & ", " & Eval("objItem." & propItem.Name)
    Next

    wscript.echo str
  Next 
end sub

ShowServices "Win32_TemperatureProbe" ' <---- This can be changed to whatever class you want

</pre>

Paste that into a .vbs file and run it with cscript, and you get output that looks like this:

<pre class="syntax">

Temperature, version 0.1
Accuracy, 32768
Availability,
Caption, Numeric Sensor
ConfigManagerErrorCode,
ConfigManagerUserConfig,
CreationClassName, Win32_TemperatureProbe
CurrentReading,
Description, CPU Internal Temperature
DeviceID, root\cimv2 0
ErrorCleared,
ErrorDescription,
InstallDate,
IsLinear,
LastErrorCode,
LowerThresholdCritical,
LowerThresholdFatal,
LowerThresholdNonCritical,
MaxReadable, 1270
MinReadable, 0
Name, Numeric Sensor
NominalReading,
NormalMax,
NormalMin,
PNPDeviceID,
PowerManagementCapabilities,
PowerManagementSupported,
Resolution, 1000
Status, OK
StatusInfo,
SystemCreationClassName, Win32_ComputerSystem
SystemName, SYSTEM_NAME
Tolerance, 5
UpperThresholdCritical,
UpperThresholdFatal,
UpperThresholdNonCritical,

</pre>

So, there is one WMI available temperature probe on my laptop, and, as the documentation
states, CurrentReading is unpopulated.  Sigh... while this isn't too useful, try running the script 
with a class like Win32_NetworkAdapter or Win32_Process.
